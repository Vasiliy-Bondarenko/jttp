<?php namespace Tests;

use Jttp\Response;
use Jttp\TransportException;
use Jttp\HttpException;
use Jttp\JttpException;
use Jttp\TooManyRedirectsException;
use PHPUnit\Framework\TestCase;
use Jttp\JsonException;
use Jttp\Jttp;
use stdClass;

class JttpTest extends TestCase
{
    protected function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub
    }

    /** @test */
    public function can_init()
    {
        // given
        $client = new Jttp();

        // assertions
        $this->assertInternalType("object", $client);
    }

    /** @test */
    public function get_ok()
    {
        // action
        $result = (new Jttp)
            ->url("https://httpbin.org/get")
            ->get();

        // assertions
        $this->assertTrue($result->isOk());
        $this->assertEquals(200, $result->status());
        $this->assertEquals("OK", $result->statusText());
        $this->assertInternalType("array", $result->json());
        $this->assertEquals("httpbin.org", $result->json()["headers"]["Host"]);
    }

    /** @test */
    public function if_bad_json_returned_body_ok_json_throws()
    {
        // action
        $result = (new Jttp)
            ->url("https://httpbin.org/base64/SFRUUEJJTiBpcyBhd2Vzb21l")
            ->get();

        // assertions
        $this->assertTrue($result->isOk());
        $this->assertEquals("HTTPBIN is awesome", $result->body());
        $this->expectException(JsonException::class);
        $result->json();
    }

    /** @test */
    public function get_404()
    {
        try {
            // action
            $result = (new Jttp)
                ->url("https://httpbin.org/status/404")
                ->get();
        } catch (HttpException $e) {
            $result = $e->response;
            // assertions
            $this->assertFalse($result->isOk());
            $this->assertEquals(404, $result->status());
            return;
        }

        $this->fail("HttpException expected, but not thrown");
    }

    /**
     * datasets for post_as_json test
     * @return array
     */
    public function post_data_provider()
    {
        $obj       = new stdClass();
        $obj->prop = "property";

        return [
            [
                [
                    "field_one" => "value_one",
                    "field_two" => "value_two",
                ],
                [
                    "field_one" => "value_one",
                    "field_two" => "value_two",
                ]
            ],
            [null, null],
            [false, false],
            ["string", "string"],
            [$obj, ["prop" => "property"]]
        ];
    }

    /**
     * @test
     * @dataProvider post_data_provider
     */
    public function post_as_json($send_data, $received_data)
    {
        // action
        $result = (new Jttp)
            ->url("https://httpbin.org/post")
            ->post($send_data);

        // assertions
        $this->assertTrue($result->isOk());
        $this->assertInternalType("array", $result->json());
        $this->assertEquals($received_data, json_decode($result->json()["data"], true));
        $this->assertEquals("application/json", $result->json()["headers"]["Content-Type"]);
    }

    public function http_verbs_data_provider()
    {
        return [
            ["patch"],
            ["delete"],
            ["put"],
        ];
    }

    /**
     * @test
     * @dataProvider http_verbs_data_provider
     */
    public function http_verbs($verb)
    {
        $send_data = [1, 2];

        // action
        $result = (new Jttp)
            ->url("https://httpbin.org/{$verb}")
            ->$verb($send_data);

        // assertions
        $this->assertTrue($result->isOk());
        $this->assertInternalType("array", $result->json());
        $this->assertEquals($send_data, json_decode($result->json()["data"], true));
    }

    /** @test */
    public function post_as_multipart()
    {
        // given
        $data = [
            "field_one" => "value_one",
            "field_two" => "value_two",
        ];

        // action
        $result = (new Jttp)
            ->url("https://httpbin.org/post")
            ->asMultipart()
            ->post($data);

        // assertions
        $this->assertTrue($result->isOk());
        $this->assertEquals("application/json", $result->header("Content-Type"));
        $this->assertInternalType("array", $result->json());
        $this->assertEquals("httpbin.org", $result->json()["headers"]["Host"]);
        $this->assertEquals($data, $result->json()["form"]);
        $this->assertStringStartsWith("multipart/form-data; boundary=", $result->json()["headers"]["Content-Type"]);
    }

    /** @test */
    public function follow_redirect()
    {
        // action
        $result = (new Jttp)
            ->url("https://httpbin.org/absolute-redirect/1")// 302 redirect
            ->get();

        // assertions
        $this->assertTrue($result->isOk());

        // action
        $result = (new Jttp)
            ->url("https://httpbin.org/redirect-to?url=https%3A%2F%2Fhttpbin.org%2Fget&status_code=301")
            ->get();

        // assertions
        $this->assertTrue($result->isOk());


        // action
        $result = (new Jttp)
            ->url("https://httpbin.org/redirect-to?url=https%3A%2F%2Fhttpbin.org%2Fget&status_code=307")
            ->get();

        // assertions
        $this->assertTrue($result->isOk());

        // action
        try {
            $result = (new Jttp)
                ->url("https://httpbin.org/redirect-to?url=https%3A%2F%2Fhttpbin.org%2Fget&status_code=304")
                ->get();
        } catch (HttpException $e) {
            return;
        }

        $this->fail("Expected HttpException because we don't want to make redirect on 304 code. Just throw.");
    }

    /** @test */
    public function follow_redirect_x_times()
    {
        try {
            // action
            $result = (new Jttp)
                ->url("https://httpbin.org/absolute-redirect/2")
                ->maxRedirects(1)
                ->get();
        } catch (TooManyRedirectsException $e) {
            $result = $e->response;
            // assertions
            $this->assertFalse($result->isOk());
            $this->assertEquals(302, $result->status());
            $this->assertEquals("http://httpbin.org/get", $result->header("Location"));
            return;
        }

        $this->fail("TooManyRedirectsException expected, but not thrown");
    }

    /** @test */
    public function doNotFollowRedirects()
    {
        $this->expectException(TooManyRedirectsException::class);

        // action
        $result = (new Jttp)
            ->url("https://httpbin.org/absolute-redirect/1")
            ->doNotFollowRedirects()
            ->get();

        // assertions
        $this->assertFalse($result->isOk());
        $this->assertEquals(302, $result->status());
        $this->assertEquals("http://httpbin.org/get", $result->header("Location"));
    }

    /** @test */
    public function log_to_file()
    {
        $file = __DIR__ . "/log.txt";
        if (file_exists($file)) {
            unlink($file);
        }

        // action
        (new Jttp)
            ->url("https://httpbin.org/get")
            ->logToFile($file)
            ->get();

        // assertions
        $this->assertFileExists($file);
        $this->assertTrue((bool) strstr(file_get_contents($file), "httpbin.org"));
    }

    /** @test */
    public function log_to_stderr()
    {
        // this will output to stderr, i don't know how to grab it and check from here. are you?..

        // action
        (new Jttp)
            ->url("https://httpbin.org/get")
            ->logToStderr()
            ->get();
    }

    /** @test */
    public function transport_exceptions()
    {
        // action
        try {
            (new Jttp)
                ->url("gibberish")
                ->get();
        } catch (TransportException $e) {
            $this->assertInstanceOf(JttpException::class, $e);
            return;
        }

        $this->fail("TransportException expected, but not thrown");
    }

    /** @test */
    public function inject_custom_response_and_transport_classes()
    {
        // action
        $response = (new Jttp)
            ->useTransport(new CustomTransport())
            ->useResponseObject(new CustomResponse())
            ->url("https://httpbin.org/get")
            ->get();

        // assertions
        $this->assertInstanceOf(CustomResponse::class, $response);
        $this->assertEquals("ok", $response->customMethod());
        $this->assertEquals("body", $response->body());
        $this->assertEquals(["Header" => "value"], $response->headers());
        $this->assertEquals(201, $response->status());
    }

    /** @test */
    public function retry_requests_on_remote_server_500_errors()
    {
        // having
        $response_500 = (new Response())->setStatusCode(500);
        $response_200 = (new Response())->setStatusCode(200);
        $responses = [$response_500, $response_500, $response_500, $response_200];

        // action
        $response = (new Jttp)
            ->useTransport((new TransportMock())->setResponses($responses))
            ->retries(3)
            ->url("https://httpbin.org/get")
            ->get();

        $this->assertTrue($response->isOk());

        // expecting next request too fail
        $this->expectException(HttpException::class);

        // action
        $response = (new Jttp)
            ->useTransport((new TransportMock())->setResponses($responses))
            ->retries(2)
            ->url("https://httpbin.org/get")
            ->get();
    }

    /** @test */
    public function retry_requests_on_dns_errors()
    {
        // having
        $response_200 = (new Response())->setStatusCode(200);

        // action
        $response = (new Jttp)
            ->useTransport((new TransportMockFailingDNS())->setResponse($response_200)->failDnsTimes(2))
            ->retries(3)
            ->url("https://httpbin.org/get")
            ->get();

        $this->assertTrue($response->isOk());

        // expecting next request too fail
        $this->expectException(TransportException::class);

        // action
        $response = (new Jttp)
            ->useTransport((new TransportMockFailingDNS())->setResponse($response_200)->failDnsTimes(2))
            ->retries(1)
            ->url("https://httpbin.org/get")
            ->get();
    }

    /** @test */
    public function pause_between_reties()
    {
        // having
        $response_200 = (new Response())->setStatusCode(200);
        $start = microtime(true);

        // action
        $response = (new Jttp)
            ->useTransport((new TransportMockFailingDNS())->setResponse($response_200)->failDnsTimes(1))
            ->retries(1)
            ->pauseBetweenRetriesMs(1000)
            ->url("https://httpbin.org/get")
            ->get();

        // assert
        $this->assertTrue($response->isOk());
        $runtime = microtime(true) - $start;
        // should be close to 1.001 sec
        $this->assertGreaterThan(1, $runtime);
        $this->assertLessThan(1.2, $runtime);
    }
}